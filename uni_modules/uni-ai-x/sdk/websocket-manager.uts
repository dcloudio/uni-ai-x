import { Chunk, ChunkChoice, ChunkChoiceDelta, RequestAiCoMessage } from '@/uni_modules/uni-ai-x/types.uts';

type BailianOptionsOnChunkFn = (chunkObj : Chunk) => void
type BailianOptionsOnErrorFn = (err : UTSJSONObject) => void
type BailianOptionsOnDoneFn = (data : UTSJSONObject) => void

export type WebSocketCallbacks = {
	onChunk ?: BailianOptionsOnChunkFn,
	onError ?: BailianOptionsOnErrorFn,
	onDone ?: BailianOptionsOnDoneFn
}

class WebSocketManager {
	private socketTask: SocketTask | null = null
	private connected: boolean = false
	private currentCallbacks: WebSocketCallbacks | null = null

	// 初始化 WebSocket 连接
	async init() {
		if (this.connected) {
			return
		}
		try {
			console.log('初始化 WebSocket 连接')
			const socketTask = await uniCloud.connectWebSocket({
				name: 'uni-ai-openclaw'
			})
			this.socketTask = socketTask
			this.connected = true

			// 设置消息监听
			socketTask.onMessage((res) => {
				this.handleMessage(res)
			})

			socketTask.onError((err) => {
				console.error('WebSocket 错误', err)
				this.connected = false
			})

			socketTask.onClose(() => {
				console.log('WebSocket 已关闭')
				this.socketTask = null
				this.connected = false
			})

			console.log('WebSocket 持久连接已建立')
		} catch (e) {
			console.error('WebSocket 连接失败', e)
		}
	}

	// 处理 WebSocket 消息
	private handleMessage(res: OnSocketMessageCallbackResult) {
		console.log('handleMessage', res)
		if (this.currentCallbacks == null) {
			return
		}
		try {
			const data = typeof res.data == 'string' ? res.data : JSON.stringify(res.data)
			const message = JSON.parse<UTSJSONObject>(data) as UTSJSONObject
			const type = message.getString('type', '')

			if (type == 'gateway_message') {
				const gatewayData = message.getJSON('data')
				// console.log('gatewayData', gatewayData)
				if (gatewayData != null) {
					const content = gatewayData.getString('text', '')
					const isDone = gatewayData.getBoolean('isDone', false)
					console.log('isDone', isDone)

					if (content.length > 0) {
						const chunkObj: Chunk = {
							choices: [{
								delta: { content: content }
							}]
						}
						this.currentCallbacks.onChunk?.(chunkObj)
					}

					if (isDone) {
						this.currentCallbacks.onDone?.({} as UTSJSONObject)
						this.currentCallbacks = null
					}
				}
			} else if (type == 'error') {
				const errMsg = message.getString('message', '未知错误')
				const errInfo: UTSJSONObject = {
					errCode: -202,
					errMsg: errMsg
				}
				this.currentCallbacks.onError?.(errInfo)
				this.currentCallbacks = null
			}
		} catch (e) {
			console.error('解析 WebSocket 消息失败', e)
		}
	}

	// 发送消息
	send(messages: RequestAiCoMessage[], model: string, callbacks: WebSocketCallbacks): boolean {
		if (this.socketTask == null || !this.connected) {
			console.error('WebSocket 未连接')
			return false
		}

		// console.log('messages',messages)
		// 最后一条用户发送的消息
		const lastUserMessage = messages.reverse().find((item) => item.role == 'user')
		// console.log('lastUserMessage', lastUserMessage)
		if (lastUserMessage == null) {
			console.error('最后一条用户发送的消息为空')
			return false
		}
		this.currentCallbacks = callbacks

		let lastUserMessageText = ''
		if (lastUserMessage.content instanceof Array) {
			lastUserMessageText = lastUserMessage.content.map((item) => item.type == 'text' ? item.text : ("图片地址：" + item.image_url?.url)).join('\n')
		} else {
			lastUserMessageText = lastUserMessage.content
		}

		const messageData = {
			text: lastUserMessageText,
			timestamp: Date.now()
		}
		this.socketTask.send({
			data: JSON.stringify(messageData),
			// data: messageData,
			success: () => {
				console.log('消息发送成功', JSON.stringify(messageData))
			},
			fail: (err) => {
				console.error('消息发送失败', err)
				const errInfo: UTSJSONObject = {
					errCode: -201,
					errMsg: '发送消息失败'
				}
				callbacks.onError?.(errInfo)
				this.currentCallbacks = null
			}
		})

		return true
	}

	// 检查连接状态
	isConnected(): boolean {
		return this.connected
	}
}

export default WebSocketManager
