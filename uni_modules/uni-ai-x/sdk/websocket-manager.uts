import { Chunk, ChunkChoice, ChunkChoiceDelta, RequestAiCoMessage } from '@/uni_modules/uni-ai-x/types.uts';

type BailianOptionsOnChunkFn = (chunkObj : Chunk) => void
type BailianOptionsOnErrorFn = (err : UTSJSONObject) => void
type BailianOptionsOnDoneFn = (data : UTSJSONObject) => void

export type WebSocketCallbacks = {
	onChunk ?: BailianOptionsOnChunkFn,
	onError ?: BailianOptionsOnErrorFn,
	onDone ?: BailianOptionsOnDoneFn
}

class WebSocketManager {
	private socketTask: SocketTask | null = null
	private connected: boolean = false
	private currentCallbacks: WebSocketCallbacks | null = null
	// WebSocket 连接
	async connectWebSocket(): Promise<void> {
		if (this.connected) {
			console.log('已经处于连接状态，无需重新连接')
			return
		}
		const socketTask: SocketTask = await uniCloud.connectWebSocket({
			name: 'uni-ai-openclaw',
			query: {
				type: "user",
				access_token: "userDefaultToken"
			}
		})
		await new Promise<void>(resolve => {
			// 连接成功时触发
			socketTask.onOpen(event => {
				console.log('WebSocket 连接成功', event)
				this.connected = true
				// 设置消息监听
				socketTask.onMessage((res) => {
					this.handleMessage(res)
				})
				socketTask.onError((err) => {
					console.error('WebSocket 错误', err)
					this.connected = false
				})
				socketTask.onClose(() => {
					console.log('WebSocket 已关闭')
					this.connected = false
				})
				this.socketTask = socketTask
				resolve()
			})
		})	
	}
	// 初始化 
	async init() {
		// 初始化 WebSocket 连接
		await this.connectWebSocket()
	}

	// 处理 WebSocket 消息
	private handleMessage(res: OnSocketMessageCallbackResult) {
		console.log('handleMessage', res)
		if (this.currentCallbacks == null) {
			return
		}
		try {
			const data = typeof res.data == 'string' ? res.data : JSON.stringify(res.data)
			const message = JSON.parse<UTSJSONObject>(data) as UTSJSONObject
			const type = message.getString('type', '')

			if (type == 'gateway_message') {
				const gatewayData = message.getJSON('data')
				// console.log('gatewayData', gatewayData)
				if (gatewayData != null) {
					const content = gatewayData.getString('text', '')
					const isDone = gatewayData.getBoolean('isDone', false)
					console.log('isDone', isDone)

					if (content.length > 0) {
						const chunkObj: Chunk = {
							choices: [{
								delta: { content: content }
							}]
						}
						this.currentCallbacks.onChunk?.(chunkObj)
					}

					if (isDone) {
						this.currentCallbacks.onDone?.({} as UTSJSONObject)
						this.currentCallbacks = null
					}
				}
			} else if (type == 'error') {
				const errMsg = message.getString('message', '未知错误')
				const errInfo: UTSJSONObject = {
					errCode: -202,
					errMsg: errMsg
				}
				this.currentCallbacks.onError?.(errInfo)
				this.currentCallbacks = null
			}
		} catch (e) {
			console.error('解析 WebSocket 消息失败', e)
		}
	}

	// 发送消息
	async send(messages: RequestAiCoMessage[], model: string, chat_id: string, callbacks: WebSocketCallbacks): Promise<boolean> {
		// 检查连接状态，如果断开则先重连
		if (!this.connected) {
			console.log('WebSocket 未连接，尝试重新连接')
			await this.connectWebSocket()

			// 重连后再次检查
			if (!this.connected) {
				console.error('WebSocket 重连失败')
				const errInfo: UTSJSONObject = {
					errCode: -203,
					errMsg: 'WebSocket 未连接，且重连失败'
				}
				callbacks.onError?.(errInfo)
				return false
			}
		}

		// console.log('messages',messages)
		// 最后一条用户发送的消息
		const lastUserMessage = messages.reverse().find((item) => item.role == 'user')
		// console.log('lastUserMessage', lastUserMessage)
		if (lastUserMessage == null) {
			console.error('最后一条用户发送的消息为空')
			return false
		}
		this.currentCallbacks = callbacks

		let lastUserMessageText = ''
		if (lastUserMessage.content instanceof Array) {
			lastUserMessageText = lastUserMessage.content.map((item) => item.type == 'text' ? item.text : ("图片地址：" + item.image_url?.url)).join('\n')
		} else {
			lastUserMessageText = lastUserMessage.content
		}

		const messageData = {
			text: lastUserMessageText,
			timestamp: Date.now(),
			chat_id: chat_id
		}
		this.socketTask!.send({
			data: JSON.stringify(messageData),
			// data: messageData,
			success: () => {
				console.log('消息发送成功', JSON.stringify(messageData))
			},
			fail: (err) => {
				console.error('消息发送失败', err)
				const errInfo: UTSJSONObject = {
					errCode: -201,
					errMsg: '发送消息失败'
				}
				callbacks.onError?.(errInfo)
				this.currentCallbacks = null
			}
		})

		return true
	}

	// 检查连接状态
	isConnected(): boolean {
		return this.connected
	}
}

export default WebSocketManager
