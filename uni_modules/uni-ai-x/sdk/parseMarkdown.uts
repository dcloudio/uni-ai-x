import { md2json, ParseMdRes, MarkdownToken } from '@/uni_modules/uni-cmark'
import { parseLineCode} from '@/uni_modules/uni-ai-x/sdk/parseCode.uts'
import proxyWeb from '@/uni_modules/uni-ai-x/sdk/proxy-web.uts'
type UpdateCallBack = (markdownTokenList : MarkdownToken[], isParseDone: boolean) => void

// 数学公式标记的映射
const mathMarkMap = new Map<string, string>([
    ['$', '$'],
    ['$$', '$$'],
    ['\\[', '\\]'],
    ['\\(', '\\)'],
    ['\\begin{', '\\end{']
])

export default class ParseMarkdown {
	updateCallBack : UpdateCallBack
	parseLock : boolean
	readyParseMdIndex : number
	nextTaskTimer : number
	oldMsgBodyLength : number
	lastParseLineCodeText : string
	markdownTokenList : MarkdownToken[] = []
	startLineIndex : number = 0
	endLineIndex : number = 1
	userAbort: boolean  = false
	// 消息接受完成
	msgReceiveDone: boolean = false
	// 找到的最后一个数学公式结尾索引
	lastMathEndIndex : number = 0
	// 与msgBody的区别在于：数学公式部分被二次加工
	myMarkdownText : string = ''
	constructor(updateCallBack : UpdateCallBack) {
		this.updateCallBack = updateCallBack
		this.parseLock = false
		this.readyParseMdIndex = 0
		this.lastParseLineCodeText = ''
		this.oldMsgBodyLength = 0
		this.nextTaskTimer = 0
		this.startLineIndex = 0
		this.endLineIndex = 1
		// console.log('ParseMarkdown constructor')
	}
	doUpdateCallBack(isParseDone: boolean) {
		// 计算拷贝耗时
		// const startTime = Date.now()
		const copyMarkdownTokenList = JSON.parse<MarkdownToken[]>(JSON.stringify(this.markdownTokenList)) as MarkdownToken[]
		// console.log('拷贝耗时', Date.now() - startTime)
		this.updateCallBack(copyMarkdownTokenList, isParseDone)
		// #ifdef WEB
		window.markdownTokenList = copyMarkdownTokenList
		// #endif
	}
	async runTask(msgBody : string) {
		// 输出当前运行在哪个线程
		// console.log('parseMarkdown.runTask Thread.currentThread().name', Thread.currentThread().name)				
		// console.log('parseMarkdown.runTask msgBody', msgBody)				
		if (msgBody.length < this.oldMsgBodyLength) {
			// console.log('Error msgBody.length < oldMsgBodyLength', msgBody.length, this.oldMsgBodyLength)
			// console.log('Error msgBody', msgBody)
			return
		}
		// console.log('runTask', this.oldMsgBodyLength)
		// 清除延迟任务
		if (this.nextTaskTimer != 0) {
			clearTimeout(this.nextTaskTimer)
			this.nextTaskTimer = 0
		}
		if (this.parseLock) {
			// console.log('parseLock', msgBody)
			// 被锁住了，延迟执行
			this.nextTaskTimer = setTimeout(() => {
				this.runTask(msgBody)
			}, 300)
			return
		}
		this.parseLock = true
		
		// 增量获得msgBody的内容，增量处理数学公式
		this.myMarkdownText = this.myMarkdownText + msgBody.slice(this.oldMsgBodyLength);
		this.oldMsgBodyLength = msgBody.length
		const withFindMathText = this.myMarkdownText.slice(this.lastMathEndIndex)
		// 找数学公式，如果发现数学公式的开头就先等待结尾，直到找到数学公式的结尾。把符合LaTeX规范的文本，包成代码格式，规范：$$...$$ 或者 $...$ 或者 \[...\] 或者 \(...\) 或者 \begin{...}（包括带*的环境）；
		const mathStartPattern = /\$\$|\$|\\\[|\\\(|\\begin\{[a-zA-Z*]+\}/;
		const mathStartIndex = withFindMathText.search(mathStartPattern)
		if (mathStartIndex != -1) {
			// 获取开头标记
			const startToken: string = withFindMathText.match(mathStartPattern)![0]!
			// console.error('发现数学公式开头', startToken, mathStartIndex)
			// 定义结尾标记
			const endToken: string = mathMarkMap.get(startToken) ?? '';
			// 如果结尾标记不在mathMarkMap中，则抛出错误
			if (endToken.length == 0) throw new Error('mathMarkMap中没有找到对应的结尾')
			// 找到结尾索引
			const mathEndIndex = withFindMathText.indexOf(endToken)
			if (mathEndIndex != -1) {
				const mathText = withFindMathText.slice(startToken.length + mathStartIndex, mathEndIndex)
				const mathCodeText = "\n```math\n" + mathText + "\n```\n"
				this.myMarkdownText = this.myMarkdownText.slice(0, this.lastMathEndIndex) + 
								withFindMathText.slice(0, mathStartIndex) + mathCodeText +
								withFindMathText.slice(mathEndIndex + endToken.length)
				this.lastMathEndIndex += mathStartIndex + mathCodeText.length - 1
			} else {
				this.parseLock = false
				return
			}
		}

		const msgBodyLines = this.myMarkdownText.split('\n')
		let markdownText = msgBodyLines.slice(this.startLineIndex, this.endLineIndex).join('\n')
		// const start = Date.now()
		let newJsonList = await this.md2jsonTask(markdownText)
		// console.error('md2jsonTask 耗时', Date.now() - start)
		if (newJsonList.length > 1 && !(newJsonList[0].type == 'table' && newJsonList[1].isClose != 1)) {
			this.endLineIndex -= 1
			this.startLineIndex = this.endLineIndex
			newJsonList[0].isClose = 1
		} else {
			this.endLineIndex += 1
		}
		if (this.endLineIndex > msgBodyLines.length) {
			this.endLineIndex = msgBodyLines.length
		}
		// 找到最后一个未闭合的元素
		const lastUnCloseTokenIndex = this.markdownTokenList.findIndex((item : MarkdownToken) => item.isClose == 0)
		if (lastUnCloseTokenIndex != -1) {
			for (let i = 0; i < newJsonList.length; i++) {
				const index = lastUnCloseTokenIndex + i
				if (index < this.markdownTokenList.length) {
					this.markdownTokenList[index] = newJsonList[i]
				} else {
					this.markdownTokenList.push(newJsonList[i])
				}
			}
		} else {
			this.markdownTokenList.push(...newJsonList)
		}
		const isParseDone = this.msgReceiveDone && msgBodyLines.length == this.endLineIndex
		if (!isParseDone && !this.userAbort) {
			setTimeout(() => {
				this.runTask(msgBody)
			}, 100)
		}
		// console.log('markdownText', markdownText)
		this.doUpdateCallBack(isParseDone)
		this.parseLock = false
	}
	async md2jsonTask(markdownText : string) : Promise<MarkdownToken[]> {
		// const start = Date.now()
		// #ifdef APP-IOS
		const jsonString = md2json(markdownText)
		// const start2 = Date.now()
		let newJsonList = JSON.parseArray<MarkdownToken>(jsonString) as MarkdownToken[]
		// console.error('JSON.parseArray 耗时', Date.now() - start2)
		// #endif
		// #ifndef APP-IOS
		const parseMdRes = md2json(markdownText) as ParseMdRes
		let newJsonList = parseMdRes.data
		// #endif
		// console.error('md2json 耗时', Date.now() - start)
		for (let i = 0; i < newJsonList.length; i++) {
			const item = newJsonList[i]
			item.uniqueId = 'u' + (this.markdownTokenList.filter(i=>i.isClose == 1).length + i)
			// 最后一个元素不闭合
			item.isClose = (i != newJsonList.length - 1 ? 1 : 0)
			
			
			if (item.type == 'table') {
				item.isClose = 0
				// #ifdef APP-ANDROID
				this.setTableContentWidth(item.tokens!)
				// #endif
			}
			// 如果是代码块，则需要把他转为高亮代码
			else if (item.type == 'code_block') {
				if (item.text == null) {
					item.text = ''
				} else {
					const lang = item.lang ?? 'text'
					if (lang == 'math') {
						const latexEl: MarkdownToken | null = await this.parseMath(item)
						if (latexEl != null) {
							newJsonList[i] = latexEl
						}
					} else if (lang == 'mermaid') {
						await this.parseMermaid(item)
					} else {
						await this.parseCodehighlight(item)
					}
				}
			}
		}
		return newJsonList
	}
	// 解析代码，实现语法高亮
	async parseCodehighlight(codeToken: MarkdownToken){
		const oldTokenItem: MarkdownToken | null = this.markdownTokenList.find((item: MarkdownToken) => item.uniqueId == codeToken.uniqueId)
		// 如果新的和之前完全没有变化则完全使用缓存
		if (oldTokenItem != null && oldTokenItem?.text == codeToken.text){
			codeToken.codeTokens = oldTokenItem.codeTokens
			return
		}
		let startLineIndex = 0
		if (oldTokenItem != null){
			// 拿到之前已经解析过的部分（退两行防止该更新的没更）
			const oldlength = oldTokenItem.codeTokens?.length ?? 0
			codeToken.codeTokens = oldTokenItem.codeTokens?.slice(0, oldlength < 2 ? 0 : oldlength - 2)
			startLineIndex = codeToken.codeTokens?.length ?? 0
		}
		const codeTextArr = codeToken.text?.split('\n') ?? []
		// console.log('codeTextArr.length', codeTextArr,codeTextArr.length, codeTextArr[startLineIndex == 0 ? 0 : startLineIndex - 1])
		for (; startLineIndex < codeTextArr.length; startLineIndex++) {
			// console.log('startLineIndex', startLineIndex)
			const lineCodeText = codeTextArr[startLineIndex] ?? ''
			// console.log('lineCodeText', lineCodeText)
			// 代码一行一行解析
			const parseCodeRes = await parseLineCode(lineCodeText, codeToken.lang ?? 'text')
			if (parseCodeRes.error == null) {
				const lineCodeToken: MarkdownToken[] = parseCodeRes.tokens
				// console.log('lineCodeText------------', lineCodeText)
				// console.log('lineCodeToken------------', lineCodeToken)
				if (codeToken.codeTokens == null) {
					codeToken.codeTokens = [lineCodeToken] as MarkdownToken[][]
				} else {
					codeToken.codeTokens.push(lineCodeToken)
				}
			} else {
				console.log('parseCodeRes.error: ', parseCodeRes.error)
			}
		}
	}
	// 解析流程图
	async parseMermaid(mermaidToken: MarkdownToken){
		await new Promise<void>((resolve) => {
			//#ifdef MP-WEIXIN
			return resolve()
			//#endif
			proxyWeb.callMethod({
				action: 'renderMermaid',
				mermaidText: mermaidToken.text
			}, (param : UTSJSONObject) => {
				const imageDataURL : string = param['imageDataURL'] as string
				if (imageDataURL.length > 0) {
					mermaidToken.href = imageDataURL
				}
				resolve()
			})
		})
	}
	// 解析数学公式
	async parseMath(mathToken: MarkdownToken): Promise<MarkdownToken | null>{
		mathToken.text = mathToken.text?.trim()
		if (mathToken.isClose == 1) {
			return await new Promise<MarkdownToken | null>((resolve) => {
				//#ifdef MP-WEIXIN
				return resolve(null)
				//#endif
				proxyWeb.callMethod({
					action: 'katexRender',
					pureMathText: mathToken.text!
				}, (param : UTSJSONObject) => {
					// console.error('katexRender-callback', param)
					const imageDataURL = param['imageDataURL'] as string | null
					const width = param['width'] as number | null
					const height = param['height'] as number | null
					const resultHtml = param['resultHtml'] as string | null
					// 创建数学公式元素
					const latexEl : MarkdownToken = {
						type: 'math',
						text: mathToken.text!,
						html: resultHtml,
						href: imageDataURL,
						width: width,
						height: height,
						isClose: 1,
						uniqueId: mathToken.uniqueId!
					}
					resolve(latexEl)
				})
			})
		}
		return null
	}
	// 设置表格内容宽度
	// #ifdef APP-ANDROID
	setTableContentWidth(tableData: MarkdownToken[]){
		// 遍历补充单元格每个文字的宽度
		for (let rowIndex = 0; rowIndex < tableData.length; rowIndex++) {
			const row = tableData[rowIndex]
			for (let cellIndex = 0; cellIndex < row.tokens!.length; cellIndex++) {
				const cell = row.tokens![cellIndex]
				for (let cellItemIndex = 0; cellItemIndex < (cell.tokens?.length ?? 0); cellItemIndex++) {
					const cellItem = cell.tokens![cellItemIndex]
					cellItem.text = cellItem.text?.replace(/\*/g, '') ?? ''
					// 单元格内每个文字的大小
					cellItem.width = this.measureTextWidth(cellItem.text, rowIndex == 0 ? 16 : 14);
					// 当前单元格的总大小
					cell.width = (cell.width ?? 0) + cellItem.width
				}
			}
		}
	}
	measureTextWidth(text : string, fontSize : number) : number {
		const layout = new UniTextLayout();
		layout.setText(text);
		layout.setFontSize(fontSize + 'px');
		return layout.measure({} as UniLayoutConstraintSize).width
	}
	// #endif
	formatMath(text: string) {
	    // 先清理输入文本中的控制字符（除了换行和制表符）
	    text = text.replace(/[\x00-\x09\x0B-\x0C\x0E-\x1F\x7F]/g, '');
	    
	    // 处理 $$...$$ 块级公式 - 必须包含数学运算符
	    text = text.replace(/\$\$([\s\S]*?)\$\$/g, '\n```math\n$1\n```\n');
	    
	    // 处理 $...$ 内联公式 - 必须包含数学运算符
	    text = text.replace(/(?<!\\)\$([^$\n]*?[\\_^&|{}[\]()+\-*=<>][^$\n]*?)\$(?!\$)/g, '\n```math\n$1\n```\n');
	    
	    // 处理 \[...\] 块级公式（这肯定是数学公式）
	    text = text.replace(/\\\[([\s\S]*?)\\]/g, '\n```math\n$1\n```\n');
	    return text;
	}
}