import { md2json, ParseMdRes, MarkdownToken } from '@/uni_modules/uni-cmark'
import { parseLineCode, ParseLineCodeRes} from '@/uni_modules/uni-ai-x/sdk/parseCode.uts'
import proxyWeb from '@/uni_modules/uni-ai-x/sdk/proxy-web.uts'
import utils from '@/uni_modules/uni-ai-x/sdk/utils.uts'
type UpdateCallBack = (markdownTokenList : MarkdownToken[], isParseDone: boolean) => void
type Md2JsonCallBack = (markdownTokenList : MarkdownToken[]) => void
type ParseMathCallBack = (mathToken: MarkdownToken | null) => void
type GetTextWidthCallBack = (width: number) => void
type CallBack = () => void

// #ifdef WEB
const Thread = {
	currentThread: () => {
		return {
			name: 'web is all main'
		}
	}
}
// #endif

// 数学公式标记的映射
const mathMarkMap = new Map<string, string>([
    ['$', '$'],
    ['$$', '$$'],
    ['\\[', '\\]'],
    ['\\(', '\\)'],
    ['\\begin{', '\\end{']
])

export default class ParseMarkdown {
	updateCallBack : UpdateCallBack
	parseLock : boolean
	readyParseMdIndex : number
	nextTaskTimer : number
	oldMsgBodyLength : number
	lastParseLineCodeText : string
	markdownTokenList : MarkdownToken[] = []
	startLineIndex : number = 0
	endLineIndex : number = 1
	userAbort: boolean  = false
	// 消息接受完成
	msgReceiveDone: boolean = false
	// 找到的最后一个数学公式结尾索引
	lastMathEndIndex : number = 0
	// 与msgBody的区别在于：数学公式部分被二次加工
	myMarkdownText : string = ''
	constructor(updateCallBack : UpdateCallBack) {
		this.updateCallBack = updateCallBack
		this.parseLock = false
		this.readyParseMdIndex = 0
		this.lastParseLineCodeText = ''
		this.oldMsgBodyLength = 0
		this.nextTaskTimer = 0
		this.startLineIndex = 0
		this.endLineIndex = 1
	}
	doUpdateCallBack(isParseDone: boolean) {
		// 计算拷贝耗时
		// const startTime = Date.now()
		const copyMarkdownTokenList = JSON.parse<MarkdownToken[]>(JSON.stringify(this.markdownTokenList)) as MarkdownToken[]
		// console.log('拷贝耗时', Date.now() - startTime)
		this.updateCallBack(copyMarkdownTokenList, isParseDone)
		// #ifdef WEB
		window.markdownTokenList = copyMarkdownTokenList
		// #endif
	}
	runTask(msgBody : string) {
		// console.log('parseMarkdown.runTask msgBody', msgBody)				
		if (msgBody.length < this.oldMsgBodyLength) {
			// console.log('Error msgBody.length < oldMsgBodyLength', msgBody.length, this.oldMsgBodyLength)
			// console.log('Error msgBody', msgBody)
			return
		}
		// console.log('runTask', this.oldMsgBodyLength)
		// 清除延迟任务
		if (this.nextTaskTimer != 0) {
			clearTimeout(this.nextTaskTimer)
			this.nextTaskTimer = 0
		}
		if (this.parseLock) {
			// console.log('parseLock', msgBody)
			// 被锁住了，延迟执行
			this.nextTaskTimer = setTimeout(() => {
				this.runTask(msgBody)
			}, 300)
			return
		}
		this.parseLock = true
		
		// 输出当前运行在哪个线程
		// console.log('currentThread.name', Thread.currentThread().name)
		
		// 增量获得msgBody的内容，增量处理数学公式
		this.myMarkdownText = this.myMarkdownText + msgBody.slice(this.oldMsgBodyLength);
		this.oldMsgBodyLength = msgBody.length
		let withFindMathText = this.myMarkdownText.slice(this.lastMathEndIndex)
		// 为排除代码块内容，被误识别为数学公式，如果发现```的数量为奇数，则认为是代码块的开始，需要暂停识别数学公式，直到出现下一个```再继续
		const codeTagIndex = withFindMathText.split('```').length - 1
		if (codeTagIndex % 2 == 0) {
			// 找到最后一个```的索引
			const lastCodeTagIndex = withFindMathText.lastIndexOf('```') + 3
			withFindMathText = withFindMathText.slice(lastCodeTagIndex)
			// 找数学公式，如果发现数学公式的开头就先等待结尾，直到找到数学公式的结尾。把符合LaTeX规范的文本，包成代码格式，规范：$$...$$ 或者 $...$ 或者 \[...\] 或者 \(...\) 或者 \begin{...}（包括带*的环境）；
			const mathStartPattern = /\$\$|\$|\\\[|\\\(|\\begin\{[a-zA-Z*]+\}/;
			const mathStartIndex = withFindMathText.search(mathStartPattern)
			if (mathStartIndex != -1) {
				// 获取开头标记
				const startToken: string = withFindMathText.match(mathStartPattern)![0]!
				// console.error('发现数学公式开头', startToken, mathStartIndex)
				// 定义结尾标记
				const endToken: string = mathMarkMap.get(startToken) ?? '';
				// 如果结尾标记不在mathMarkMap中，则抛出错误
				if (endToken.length == 0) throw new Error('mathMarkMap中没有找到对应的结尾')
				// 找到结尾索引（排除开头标记，因为有的开头和结尾的标记是一样的）
				const _index = withFindMathText.slice(mathStartIndex + startToken.length).indexOf(endToken)
				const hasMathEndTag = _index != -1
				if (hasMathEndTag) {
					const mathEndIndex = _index + mathStartIndex + startToken.length
					const mathText = withFindMathText.slice(startToken.length + mathStartIndex, mathEndIndex)
					const mathCodeText = "\n```math\n" + mathText + "\n```\n"
					this.myMarkdownText = this.myMarkdownText.slice(0, this.lastMathEndIndex + lastCodeTagIndex) + 
									withFindMathText.slice(0, mathStartIndex) + mathCodeText +
									withFindMathText.slice(mathEndIndex + endToken.length)
					this.lastMathEndIndex += lastCodeTagIndex + mathStartIndex + mathCodeText.length - 1
				} else {
					this.parseLock = false
					return
				}
			}
		}

		const msgBodyLines = this.myMarkdownText.split('\n')
		let markdownText = msgBodyLines.slice(this.startLineIndex, this.endLineIndex).join('\n')
		const isParseDone = this.msgReceiveDone && msgBodyLines.length == this.endLineIndex
		const start = Date.now()
		// console.error('s')
		this.md2jsonTask(markdownText, (newJsonList)=>{
			// #ifdef  APP-ANDROID
			if (Thread.currentThread().name == 'main') {
				console.error('意外回到主线程执行了')
			}
			// #endif
			// console.error('md2jsonTask 耗时', Date.now() - start)
			// console.error('e')
			if (newJsonList.length > 1 && !(newJsonList[0].type == 'table' && newJsonList[1].isClose != 1)) {
				this.endLineIndex -= 1
				this.startLineIndex = this.endLineIndex
				newJsonList[0].isClose = 1
			} else {
				this.endLineIndex += 1
			}
			if (this.endLineIndex > msgBodyLines.length) {
				this.endLineIndex = msgBodyLines.length
			}
			// 找到最后一个未闭合的元素
			const lastUnCloseTokenIndex = this.markdownTokenList.findIndex((item : MarkdownToken) => item.isClose == 0)
			if (lastUnCloseTokenIndex != -1) {
				for (let i = 0; i < newJsonList.length; i++) {
					const index = lastUnCloseTokenIndex + i
					if (index < this.markdownTokenList.length) {
						this.markdownTokenList[index] = newJsonList[i]
					} else {
						this.markdownTokenList.push(newJsonList[i])
					}
				}
			} else {
				this.markdownTokenList.push(...newJsonList)
			}
			if (!isParseDone && !this.userAbort) {
				setTimeout(() => {
					this.runTask(msgBody)
				}, 100)
			}
			// console.log('markdownText', markdownText)
			this.doUpdateCallBack(isParseDone)
			this.parseLock = false
		})
	}
	md2jsonTask(markdownText : string, md2JsonCallBack: Md2JsonCallBack ) {
		// const start = Date.now()
		// #ifdef APP-IOS
		const jsonString = md2json(markdownText)
		// const start2 = Date.now()
		let newJsonList = JSON.parseArray<MarkdownToken>(jsonString) as MarkdownToken[]
		// console.error('JSON.parseArray 耗时', Date.now() - start2)
		// #endif
		// #ifndef APP-IOS
		const parseMdRes = md2json(markdownText) as ParseMdRes
		let newJsonList = parseMdRes.data
		// #endif
		// console.error('md2json 耗时', Date.now() - start)
		if (newJsonList.length == 0) {
			md2JsonCallBack([])
			return
		}
		const beforeDone = this.createBeforeDone(newJsonList.length, ()=> md2JsonCallBack(newJsonList))
		for (let i = 0; i < newJsonList.length; i++) {
			const item = newJsonList[i]
			item.uniqueId = 'u' + (this.markdownTokenList.filter(i=>i.isClose == 1).length + i)
			// 最后一个元素不闭合
			item.isClose = (i != newJsonList.length - 1 ? 1 : 0)
			if (item.type == 'table') {
				item.isClose = 0
				this.setTableContentWidth(item.tokens!,()=>{
					beforeDone()
				})
			} else if (item.type == 'code_block') { // 如果是代码块，则需要把他转为高亮代码
				if (item.text == null) {
					item.text = ''
					beforeDone()
				} else {
					const lang = item.lang ?? 'text'
					if (lang == 'math') {
						const index = i
						this.parseMath(item, (latexEl: MarkdownToken | null)=>{
							if (latexEl != null) {
								newJsonList[index] = latexEl
							}
							beforeDone()
						})
					} else if (lang == 'mermaid') {
						this.parseMermaid(item, ()=>{
							beforeDone()
						})
					} else {
						this.parseCodehighlight(item, ()=>{
							beforeDone()
						})
					}
				}
			} else {
				beforeDone()
			}
		}
	}
	// 解析代码，实现语法高亮
	parseCodehighlight(codeToken: MarkdownToken, callBack: CallBack){
		const oldTokenItem: MarkdownToken | null = this.markdownTokenList.find((item: MarkdownToken) => item.uniqueId == codeToken.uniqueId)
		// 如果新的和之前完全没有变化则完全使用缓存
		if (oldTokenItem != null && oldTokenItem?.text == codeToken.text){
			codeToken.codeTokens = oldTokenItem.codeTokens
			callBack()
			return
		}
		let startLineIndex = 0
		if (oldTokenItem != null){
			// 拿到之前已经解析过的部分（退两行防止该更新的没更）
			const oldlength = oldTokenItem.codeTokens?.length ?? 0
			codeToken.codeTokens = oldTokenItem.codeTokens?.slice(0, oldlength < 2 ? 0 : oldlength - 2)
			startLineIndex = codeToken.codeTokens?.length ?? 0
		}
		const codeTextArr = codeToken.text?.split('\n') ?? []
		const beforeDone = this.createBeforeDone(codeTextArr.length - startLineIndex, callBack)
		// console.log('codeTextArr.length', codeTextArr,codeTextArr.length, codeTextArr[startLineIndex == 0 ? 0 : startLineIndex - 1])
		for (; startLineIndex < codeTextArr.length; startLineIndex++) {
			// console.log('startLineIndex', startLineIndex)
			const lineCodeText = codeTextArr[startLineIndex] ?? ''
			// 代码一行一行解析
			parseLineCode((parseCodeRes: ParseLineCodeRes)=>{
				// console.log('parseCodeRes', parseCodeRes)
				if (parseCodeRes.error == null) {
					const lineCodeToken: MarkdownToken[] = parseCodeRes.tokens
					// console.log('lineCodeText------------', lineCodeText)
					// console.log('lineCodeToken------------', lineCodeToken)
					if (codeToken.codeTokens == null) {
						codeToken.codeTokens = [lineCodeToken] as MarkdownToken[][]
					} else {
						codeToken.codeTokens.push(lineCodeToken)
					}
				} else {
					console.log('parseCodeRes.error: ', parseCodeRes.error)
				}
				beforeDone()
			},lineCodeText, codeToken.lang ?? 'text')
		}
	}
	// 解析流程图
	parseMermaid(mermaidToken: MarkdownToken, callBack: CallBack){
		//#ifdef MP-WEIXIN
		callBack()
		//#endif
		// #ifndef MP-WEIXIN
		proxyWeb.callMethod({
			action: 'renderMermaid',
			mermaidText: mermaidToken.text
		}, (param : UTSJSONObject) => {
			const imageDataURL : string = param['imageDataURL'] as string
			if (imageDataURL.length > 0) {
				mermaidToken.href = imageDataURL
			}
			callBack()
		})
		// #endif
	}
	// 解析数学公式
	parseMath(mathToken: MarkdownToken, callBack: ParseMathCallBack){
		// #ifdef MP-WEIXIN
		callBack(null)
		// #endif
		// #ifndef MP-WEIXIN
		mathToken.text = mathToken.text?.trim()
		if (true || mathToken.isClose == 1) {
			proxyWeb.callMethod({
				action: 'katexRender',
				pureMathText: mathToken.text!
			}, (param : UTSJSONObject) => {
				// console.error('katexRender-callback', param)
				const imageDataURL = param['imageDataURL'] as string | null
				const width = param['width'] as number | null
				const height = param['height'] as number | null
				const resultHtml = param['resultHtml'] as string | null
				// 创建数学公式元素
				const latexEl : MarkdownToken = {
					type: 'math',
					text: mathToken.text!,
					html: resultHtml,
					href: imageDataURL,
					width: width,
					height: height,
					isClose: 0,
					uniqueId: mathToken.uniqueId!
				}
				callBack(latexEl)
			})
		} else {
			callBack(null)
		}
		// #endif
	}
	// 设置表格内容宽度
	setTableContentWidth(tableData: MarkdownToken[], callBack: CallBack){
		const totalCount = tableData.reduce((sum, row) => sum + (row.tokens?.reduce((sum, cell) => sum + (cell.tokens?.length ?? 0), 0) ?? 0), 0)
		const beforeDone = this.createBeforeDone(totalCount, callBack)
		// 遍历补充单元格每个文字的宽度
		for (let rowIndex = 0; rowIndex < tableData.length; rowIndex++) {
			const row = tableData[rowIndex]
			for (let cellIndex = 0; cellIndex < row.tokens!.length; cellIndex++) {
				const cell = row.tokens![cellIndex]
				// totalCount += cell.tokens?.length ?? 0
				for (let cellItemIndex = 0; cellItemIndex < (cell.tokens?.length ?? 0); cellItemIndex++) {
					const cellItem = cell.tokens![cellItemIndex]
					const cellItemText = cellItem.text ?? utils.getTokensText(cellItem.tokens)
					// 单元格内每个文字的大小
					this.getMeasureTextWidth((textWidth: number)=>{
						cellItem.width = textWidth
						// 当前单元格的总大小
						cell.width = (cell.width ?? 0) + cellItem.width
						beforeDone()
					},cellItemText, rowIndex == 0 ? 16 : 14);
				}
			}
		}
	}
	getMeasureTextWidth(callBack: GetTextWidthCallBack, text : string, fontSize : number){
		// #ifdef APP-ANDROID
		const layout = new UniTextLayout();
		layout.setText(text);
		layout.setFontSize(fontSize + 'px');
		const width = layout.measure({} as UniLayoutConstraintSize).width
		callBack(width)
		// #endif
		// #ifndef APP-ANDROID
		utils.measureTextWidth(text, fontSize).then((width: number)=>{
			callBack(width)
		})
		// #endif
	}
	createBeforeDone(totalCount: number, callBack: CallBack){
		let parseCount = 0;
		return () => {
			parseCount++
			if (parseCount == totalCount) {
				callBack()
			}
		}
	}
}