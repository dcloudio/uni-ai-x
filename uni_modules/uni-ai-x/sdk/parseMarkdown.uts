import {useMarked, TokensList, NodesToken as MarkdownToken, TableCell} from '@/uni_modules/kux-marked';
import {IToken, parseCode, ParseCodeRes} from '@/uni_modules/uni-ai-x/sdk/parseCode.uts'
import proxyWeb from '@/uni_modules/uni-ai-x/sdk/proxy-web.uts'
const marked = useMarked()
type UpdateCallBack = (markdownTokenList: MarkdownToken[]) => void

// 数学公式标记的映射
const mathMarkMap = new Map<string, string>([
    ['$', '$'],
    ['$$', '$$'],
    ['\\[', '\\]'],
    ['\\(', '\\)'],
    ['\\begin{', '\\end{']
])
export default class ParseMarkdown {
    updateCallBack: UpdateCallBack
    parseLock: boolean
    readyParseMdIndex: number
    nextTaskTimer: number
    oldMsgBodyLength: number
    lastParseLineCodeText: string
    markdownTokenList: MarkdownToken[] = []
    constructor(updateCallBack: UpdateCallBack) {
        this.updateCallBack = updateCallBack
        this.parseLock = false
        this.readyParseMdIndex = 0
        this.lastParseLineCodeText = ''
        this.oldMsgBodyLength = 0
        this.nextTaskTimer = 0
        // console.log('ParseMarkdown constructor')
    }
    doUpdateCallBack(){
        // 计算拷贝耗时
        // const startTime = Date.now()
        const copyMarkdownTokenList = JSON.parse<MarkdownToken[]>(JSON.stringify(this.markdownTokenList)) as MarkdownToken[]
        // console.log('拷贝耗时', Date.now() - startTime)
        this.updateCallBack(copyMarkdownTokenList)
        // #ifdef WEB
        window.markdownTokenList = copyMarkdownTokenList
        // #endif
    }
    runTask(msgBody: string){
        // 输出当前运行在哪个线程
        // console.log('parseMarkdown.runTask Thread.currentThread().name', Thread.currentThread().name)				
        // console.log('parseMarkdown.runTask msgBody', msgBody)				
        if (msgBody.length < this.oldMsgBodyLength) {
            // console.log('Error msgBody.length < oldMsgBodyLength', msgBody.length, this.oldMsgBodyLength)
            // console.log('Error msgBody', msgBody)
            return
        }
        this.oldMsgBodyLength = msgBody.length
        // console.log('runTask', this.oldMsgBodyLength)
        // 清除延迟任务
        if (this.nextTaskTimer != 0) {
            clearTimeout(this.nextTaskTimer)
            this.nextTaskTimer = 0
        }
        if (this.parseLock) {
            // console.log('parseLock', msgBody)
            // 被锁住了，延迟执行
            this.nextTaskTimer = setTimeout(() => {
                this.runTask(msgBody)
            }, 300)
            return
        }
        this.parseLock = true
        // 新增的 markdown 文本
        const newMd = msgBody.slice(this.readyParseMdIndex)
        // 更新准备解析的 markdown 文本 = 新增的 markdown 文本的\n 之前的部分
        this.readyParseMdIndex +=  (newMd.includes('\n') ? newMd.split('\n')[0] + '\n' : newMd).length
        const parseMdIndex = this.markdownTokenList.filter(item => item.isClose == true).map(item => item.raw?.length ?? 0).reduce((a, b) => a + b, 0)
        // console.log('parseMdIndex', parseMdIndex)
        // 拿到本次解析的文本
        let markdownText = msgBody.slice(parseMdIndex, this.readyParseMdIndex)
        // console.error('111markdownText', markdownText)
        // 解析代码
        this.parseCodeTask(markdownText).then((newMarkdownText: string) => {
            // console.log('after parseCodeTask', newMarkdownText)
            // 解析数学公式
            this.parseMathTask(newMarkdownText).then((newMarkdownText: string) => {
            // console.log('after parseMathTask', newMarkdownText)
                // console.log('222newMarkdownText', newMarkdownText)
                // 解析 markdown
                this.parseMarkdownTask(newMarkdownText)
                this.parseLock = false
                const lastItemRawLength = this.markdownTokenList.length > 0 ? (this.markdownTokenList[this.markdownTokenList.length - 1].raw?.length ?? 0) : 0
                if (this.readyParseMdIndex < msgBody.length || (parseMdIndex + lastItemRawLength) < msgBody.length) {
                    // console.log('未全部完成，设置延迟任务')
                    this.nextTaskTimer = setTimeout(() => {
                        this.runTask(msgBody)
                    }, 300)
                }
            })  
        })
    }
    parseMathTask(markdownText: string): Promise<string>{
        //#ifdef uniVersion < 4.81 && APP-IOS || MP-WEIXIN
        return new Promise((resolve) => {
            resolve(markdownText)
        })
        //#endif
        return new Promise((resolve) => {
            // 解析LaTeX数学公式，规范：$$...$$ 或者 $...$ 或者 \[...\] 或者 \(...\) 或者 \begin{...}（包括带*的环境）；找到开头索引
            const mathStartPattern = /\$\$|\$|\\\[|\\\(|\\begin\{[a-zA-Z*]+\}/;
            const mathStartIndex = markdownText.search(mathStartPattern)
            if (mathStartIndex == -1) {
                // console.error('markdownText 不包含数学公式', markdownText)
                return resolve(markdownText)
            } else if (mathStartIndex != 0) {
                // 不是以数学公式开头，需要将数学公式之前的文本解析出来
                const beforeMathText = markdownText.slice(0, mathStartIndex)
                // 解析 markdown
                const newTokenList: MarkdownToken[] = this.markedLexer(beforeMathText)
                newTokenList.forEach((item: MarkdownToken) => {
                    item.isClose = true
                })
                // 删除原列表中未闭合的元素
                this.markdownTokenList = this.markdownTokenList.filter((item: MarkdownToken) => item.isClose == true)
                // 添加新的元素
                this.markdownTokenList.push(...newTokenList)
                this.doUpdateCallBack()
                return resolve('')
            }
            // 获取开头标记
            const startToken: string = markdownText.match(mathStartPattern)![0]!
            // 定义结尾标记
            let endToken: string | null;
            if (startToken.startsWith('\\begin{')) {
                endToken = '\\end{' + startToken.slice(7)
            } else {
                endToken = mathMarkMap.get(startToken)
            }
            // console.error('startToken', startToken, 'endToken', endToken, 'markdownText', markdownText)
            // 从开始标记结束后(避免开始和结束标记相等时识别错误)，找到结尾标记
            let endIndex = markdownText.slice(startToken.length).indexOf(endToken!)
            if (endIndex == -1) {
                // console.log('未找到数学公式结尾标记：' + endToken, 'markdownText', markdownText)
                // 返回空字符串，触发暂停其他解析，待下一次字符串变化时，继续解析
                return resolve('')
            }
            // 拿到数学公式
            const mathText = markdownText.slice(0, endIndex + startToken.length + endToken!.length)
            // console.log('拿到~~~~原始数学公式 mathText', mathText, 'markdownText', markdownText)
            // 请求库解析数学公式，并插入到 dom 中
            // 提取纯数学表达式内容（去掉标记符号）
            let pureMathText: string = mathText
            // 如果开始标记不是 \begin{} 格式，则去掉开始和结束标记
            if (!startToken.startsWith('\\begin{')){
                const markLength = startToken.length
                pureMathText = mathText.slice(markLength, -1 * markLength)
            }

            // console.log('拿到~~~~纯文本数学公式 pureMathText', pureMathText)

            proxyWeb.callMethod({
                action: 'katexRender',
                pureMathText
            }, (param: UTSJSONObject) => {
                // console.error('katexRender-callback', param)
				const imageDataURL = param['imageDataURL'] as string | null
                const resultHtml = param['resultHtml'] as string | null
                // 创建数学公式元素
                const mathToken: MarkdownToken = {
                    type: 'math',
                    raw: mathText,
                    html: resultHtml,
                    href: imageDataURL,
                    isClose: true,
                    uniqueId: this.getUniqueId(this.markdownTokenList.length)
                }
                // 找到最后1个未闭合的元素，并替换。如果未找到，则添加到末尾
                const lastUnCloseTokenIndex = this.markdownTokenList.findIndex((item: MarkdownToken) => item.isClose == false)
                if (lastUnCloseTokenIndex != -1) {
                    this.markdownTokenList[lastUnCloseTokenIndex] = mathToken
                } else {
                    this.markdownTokenList.push(mathToken)
                }
                this.doUpdateCallBack()
                resolve('')
            })
        })
    }
    measureTextWidth(text: string, fontSize: number){
		const layout = new UniTextLayout();
		layout.setText(text);
		layout.setFontSize(fontSize + 'px');
		const measureSize = layout.measure({} as UniLayoutConstraintSize);
		return measureSize.width + 16 // 加上padding
	}
    markedLexer(markdownText: string): MarkdownToken[] {
        const newTokenList: MarkdownToken[] = (marked.lexer(markdownText,null) as TokensList).tokens as MarkdownToken[]
        newTokenList.forEach((item: MarkdownToken, index: number) => {
            // 时间戳 + 序号 + 随机的 5 位尾数
            item.uniqueId = this.getUniqueId(index)
            // 为多项的时候，除倒数第1项，其他项一定为闭合的
            item.isClose = true
            //#ifdef APP-ANDROID
            // 如果类型是 table，则设置宽度
            if (item.type == 'table') {
                item.rows?.forEach((rows: TableCell[]) => {
                    rows.forEach((cell: TableCell) => {
                        cell.width = this.measureTextWidth(cell.text.replace(/\*/g, ''), 14)
                    })
                })
                item.header?.forEach((cell: TableCell) => {
                    cell.width = this.measureTextWidth(cell.text.replace(/\*/g, ''), 16)
                })
            }
            //#endif
            // #ifdef APP-HARMONY
            // TODO：临时方案解决鸿蒙平台的解析错误的 bug。如果是 paragraph 类型，且可能是代码块的开头，即包含 ```+语言名称 + 换行符，例如 ```javascript\n
            if (item.type == 'paragraph' && /```[a-zA-Z]+\n/.test(item.raw!)) {
                item.type = 'code'
                item.isClose = false
            }
            // #endif
        })

        // 设置倒数第1项的闭合状态
        const lastNewToken = newTokenList[newTokenList.length - 1]!
        // 需要双换行闭合的类型
        const doubleNewlineTypes = ['list', 'code', 'blockquote', "html"]
        // 需要单换行闭合的类型
        const singleNewlineTypes = ['paragraph', 'heading', 'hr',  'def', 'space']
        // 不需要换行闭合的类型，表格只要能解析出来都当闭合处理
        const noNewlineTypes = ['table', 'text', 'strong', 'em', 'del', 'link', 'image', 'codespan']
        const type = lastNewToken.type!
        if (doubleNewlineTypes.includes(type)) {
            lastNewToken.isClose = lastNewToken.raw!.includes('\n\n')
        } else if (singleNewlineTypes.includes(type)) {
            lastNewToken.isClose = lastNewToken.raw!.includes('\n')
        } else if (noNewlineTypes.includes(type)) {
            lastNewToken.isClose = true
        } else {
            console.error('未知元素类型', lastNewToken)
        }

        return newTokenList
    }
    parseCodeTask(markdownText: string): Promise<string>{
        return new Promise((resolve) => {
            // 如果 lastToken 是代码块，并且以 ``` 开头 (无序列表不完整时可能会被解析成代码块)，则不继续解析 markdown
            // 从 this.markdownTokenList 中找到第一个未闭合的 codeToken，性能要好
            const codeTokenIndex: number = this.markdownTokenList.findIndex((token: MarkdownToken) => token.type == 'code' && token.isClose == false)
            if (codeTokenIndex == -1) {
                return resolve(markdownText)
            }
            const codeToken: MarkdownToken | null = this.markdownTokenList[codeTokenIndex]
            if (codeToken != null && markdownText.split('\n').length > 0 && markdownText.startsWith('```')) {
                // 按行分割第 1 行是 ``` + lang，第 2 行起是代码内容
                const codeTokenArr = markdownText.split('\n')
                // console.error('codeTokenArr', codeTokenArr)
                const lang = codeTokenArr[0].slice(3)
                codeToken.lang = lang
                // console.log('lang', lang, codeToken.lang)
                // 去掉首行和末行的 ``` + 换行符
                let codeText = codeTokenArr.slice(1).join('\n')
                // 找到```+换行符的索引
                const codeEndIndex = codeText.indexOf('```\n')
                // 更新代码块的 raw 属性
                if (codeEndIndex != -1) {
                    // 更新代码块的 raw 属性，lang 是语言名称，codeEndIndex 是代码的长度，8 是 2个 ``` + 2个换行符
                    codeToken.raw = markdownText.slice(0, lang.length + codeEndIndex + 8)
                    codeText = codeText.slice(0, codeEndIndex)
                } else {
                    codeToken.raw = markdownText
                }
                // console.error('codeEndIndex', codeEndIndex, codeText)
                
                const lastLineText = codeTokenArr.slice(-1)[0]
                // console.log('lastLineText', lastLineText)
                if ('```'.includes(lastLineText) && lastLineText != '') {
                    codeText = codeText.slice(0, -1 * lastLineText.length)
                }
                codeToken.text = codeText.trim()


                // console.log('codeToken.codeTokens.length',codeToken.codeTokens!.length)
                // 当前已经解析的代码行数
                const codeTokneLength = codeToken.codeTokens?.length ?? 0
                // 1次只解析1行代码。按行分割代码
                const codeTextArr = codeText.split('\n')
                // 拿到本次要解析的代码
                let lineCodeText: string | null = null;
                // 拿到上一次解析过的那行代码所在位置的新代码
                const lastLineCodeIndex = codeTokneLength == 0 ? 0 : codeTokneLength - 1
                const lastLineCodeNewText: string = codeTextArr[lastLineCodeIndex]
                // 判断上一次解析过的那行代码是否更新了
                const lastLineCodeTextIsUpdate = this.lastParseLineCodeText != lastLineCodeNewText
                // console.log('lastLineCodeTextIsUpdate', lastLineCodeTextIsUpdate)
                let currentLineCodeIndex = lastLineCodeIndex
                if (lastLineCodeTextIsUpdate) {
                    // 如果更新了，设为本次要解析的代码
                    lineCodeText = lastLineCodeNewText
                } else if (codeTokneLength < codeTextArr.length) {
                    // 如果不变说明，应当解析下一行代码
                    currentLineCodeIndex += 1
                    lineCodeText = currentLineCodeIndex > (codeTextArr.length - 1) ? '' : codeTextArr[currentLineCodeIndex]
                }
                let parseComplete = codeEndIndex != -1 && codeTokneLength == codeTextArr.length
                // console.log('parseComplete codeToken.codeTokens', codeToken.codeTokens)
                // 保存本次要解析的代码
                this.lastParseLineCodeText = lineCodeText ?? ''
                // 3. 解析代码
                if (lineCodeText != null) {
                    parseCode(lineCodeText,lang).then((parseCodeRes: ParseCodeRes) => {
                        const lineCodeToken: IToken[] = parseCodeRes.tokens
                        if (parseCodeRes.error != null) {
                            let canParseMermaid = true
                            //#ifdef uniVersion < 4.81 && APP-IOS || MP-WEIXIN
                            canParseMermaid = false
                            //#endif
                            // 如果是 mermaid 代码，则需要解析流程图
                            if (lang == 'mermaid' && canParseMermaid) {
                                proxyWeb.callMethod({
                                    action: 'renderMermaid',
                                    mermaidText: codeText
                                }, (param: UTSJSONObject) => {
                                    const imageDataURL: string = param['imageDataURL'] as string
                                    if (imageDataURL.length > 0) {
                                        codeToken.href = imageDataURL
                                    }
                                    markdownText = this.afterParseCodeTask(codeEndIndex != -1, markdownText, codeToken)
                                    resolve(markdownText)
                                })
                            } else {
                                markdownText = this.afterParseCodeTask(codeEndIndex != -1, markdownText, codeToken)
                                this.doUpdateCallBack()
                                // console.warn(`暂不支持${lang}语言的代码高亮解析，源代码：`, codeText)
                                resolve(markdownText)
                            }
                            return
                        } else {
                            lineCodeToken.forEach((item: IToken, index: number) => {
                                item.uniqueId = codeToken.uniqueId + '_r_' + currentLineCodeIndex + '_c_' + index.toString() //+ item.text
                            })
                            if (codeToken.codeTokens == null) {
                                codeToken.codeTokens = [lineCodeToken] as IToken[][]
                            } else if (lastLineCodeTextIsUpdate) {
                                codeToken.codeTokens[codeTokneLength - 1] = lineCodeToken
                                // console.log('更新代码块', codeToken.codeTokens[codeTokneLength - 1])
                            } else {
                                codeToken.codeTokens.push(lineCodeToken)
                            }
                        }
                        // console.log('codeToken.codeTokens.length', codeToken.codeTokens?.length)
                        markdownText = this.afterParseCodeTask(parseComplete, markdownText, codeToken)
                        // console.log('markdownText', markdownText)
                        // #ifdef APP-HARMONY
                        nextTick(() => {
                            // console.log('延迟完成代码解析')
                            resolve(markdownText)
                        })
                        // #endif
                        // #ifndef APP-HARMONY
                        resolve(markdownText)
                        // #endif
                    }).catch((error) => {
                        console.warn('代码高亮解析器返回的错误信息：',error)
                        resolve(markdownText)
                    })
                    return // 等待异步解析完成
                }
                markdownText = this.afterParseCodeTask(parseComplete, markdownText, codeToken)
                // console.log('markdownText', markdownText)
            }
            return resolve(markdownText)
        })
    }
    afterParseCodeTask(parseComplete: boolean, markdownText: string, codeToken: MarkdownToken): string {
        if (parseComplete == false) {
            this.doUpdateCallBack()
            // console.error('代码还没结束', markdownText, parseComplete)
            setTimeout(() => {
                this.runTask(markdownText)
            }, 300)
            return ''
        }
        // 闭合代码块
        codeToken.isClose = true
        this.doUpdateCallBack()
        markdownText = markdownText.slice(codeToken.raw!.length)
        // console.log('CompleteParseCodeTask', markdownText)
        return markdownText
    }
    getUniqueId(index: number): string {
        const timestamp: string = Date.now().toString()
        const idx: string = index.toString()
        const randomSuffix: string = Math.floor(Math.random() * 100000).toString().padStart(5, '0')
        return `${timestamp}_${idx}_${randomSuffix}`
    }
    parseMarkdownTask(markdownText: string){
        // console.log('parseMarkdownTask markdownText========>',markdownText)
        if (markdownText.length == 0) {
            // console.log('markdownText.length == 0')
            return // 空了，不继续执行
        }
        const newTokenList: MarkdownToken[] = this.markedLexer(markdownText)
        if (newTokenList.length == 0) {
            // console.log('newTokenList.length == 0')
            return // 没有新增的元素，不继续执行
        }
        // console.log('parseMarkdownTask newTokenList', JSON.parse(JSON.stringify(newTokenList)))


        // 把原列表项中未闭合的项，更新为新列表项
        const unCloseTokenIndex = this.markdownTokenList.findIndex(token => token.isClose == false)
        if (unCloseTokenIndex != -1) {
            // 更新未闭合的旧元素。如果数量更多，需要新增
            for (let i = 0; i < newTokenList.length; i++) {
                const index = unCloseTokenIndex + i
                if (index < this.markdownTokenList.length) {
                    this.markdownTokenList[index] = newTokenList[i]!
                } else {
                    this.markdownTokenList.push(newTokenList[i]!)
                }
            }
        } else {
            this.markdownTokenList.push(...newTokenList)
        }

        const firstNewToken = newTokenList[0]!
        if (newTokenList.length == 1 && firstNewToken.type == 'paragraph' && firstNewToken.isClose == true) {
            // 当倒数第2项是 table、list、paragraph 类型，且倒数第1项是 paragraph 类型，尝试合并后两项，如果合并成功，则删除后两项，并添加合并后的元素
            const mdTLLength = this.markdownTokenList.length
            const last2Token: MarkdownToken | null = mdTLLength > 1 ? this.markdownTokenList[mdTLLength - 2] : null
            if (mdTLLength > 1 && ['table', 'list', 'paragraph'].includes(last2Token!.type!)) {
                // 最后2项闭合的 + 所有未闭合的
                const newMdText = this.markdownTokenList[mdTLLength - 2]!.raw! + this.markdownTokenList[mdTLLength - 1]!.raw!
                // console.log('newMdText', newMdText)
                const combineTokenList = this.markedLexer(newMdText)
                if (combineTokenList.length == 1 && combineTokenList[0]!.type != firstNewToken.type){
                    this.markdownTokenList[mdTLLength - 2] = combineTokenList[0]!
                    this.markdownTokenList.splice(mdTLLength - 1, 1)
                    // console.log('合并后', JSON.parse(JSON.stringify(this.markdownTokenList)))
                } else {
                    // console.log('合并失败')
                }
            }
        }
        this.doUpdateCallBack()
    }
}