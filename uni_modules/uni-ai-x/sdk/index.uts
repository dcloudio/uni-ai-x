import { reactive, watch } from 'vue';
import { defaultLLM, currentUser } from '../config';
import { Llm,ChatItem,Chunk,Chat, Provider, MsgItem, RequestAiCoMessage, Userinfo, BaseMsgItem, Setting, markdownElItem } from '@/uni_modules/uni-ai-x/types.uts';
export { MsgItem, ChatItem, BaseMsgItem, Userinfo, markdownElItem }
import { llmModelMap } from '@/uni_modules/uni-ai-x/config.uts';
import { NodesToken as MarkdownToken } from '@/uni_modules/kux-marked';
import ParseMarkdown from '@/uni_modules/uni-ai-x/sdk/parseMarkdown';
import testMarkdownText from '@/uni_modules/uni-ai-x/components/uni-ai-x-msg/testMarkdownText.uts';
import treeToListSdk from '@/uni_modules/uni-ai-x/sdk/treeToList';
type OnChunkFn = (chunkObj: Chunk) => void
type BailianOptionsOnChunkFn = (chunkObj: Chunk) => void
type BailianOptionsOnErrorFn = (err: UTSJSONObject) => void
type BailianOptionsOnDoneFn = (data: UTSJSONObject) => void
type BailianOptionsOnSuccessFn = (chunkObj: Chunk) => void
type BailianOptions = {
	messages: RequestAiCoMessage[],
	stream?: boolean,
	onChunk?: BailianOptionsOnChunkFn,
	onError?: BailianOptionsOnErrorFn,
	onDone?: BailianOptionsOnDoneFn,
	onSuccess?: BailianOptionsOnSuccessFn
}
type CheckDiffEndFn = () => void
type CheckDiffFn = (index: number, checkDiffEndFn: CheckDiffEndFn) => void
type BeforeRequestAiFn = () => void
type BeforeUpdateMdElList = (markdownTokenList: MarkdownToken[]) => void;
// 请求任务列表
let requestTask: RequestTask | null = null

function checkThreadInMain(taskName: string) {
	// #ifdef APP-ANDROID
	if (Thread.currentThread().name == 'main') {
		console.log('任务：' taskName, '在主线程执行')
	}
	// #endif
}
class UniAi {
	canRender: boolean = true
	// 当前用户
	currentUser: Userinfo = currentUser
	setting: Setting = reactive<Setting>({
		// UI 主题
		theme: 'light',
		// 语言
		language: 'zh-CN'
	})
	// 大模型
	llm: Llm = reactive<Llm>({
		// 当前提供商
		provider: defaultLLM.provider,
		// 当前模型
		model: defaultLLM.model,
		// 是否开启联网搜索
		webSearch: false
	})
	chat: Chat = reactive<Chat>({
		datas: reactive<ChatItem[]>([]) as ChatItem[],
		activeId: ''
	})
	// 当前对话
	get currentChat(): ChatItem | null {
		return this.chat.datas.find((item) => item.id == this.chat.activeId) as ChatItem | null
	}
	getLocalMsgId(): string {
		// 生成一个 local_ 开头的随机字符串
		return 'local_' + (this.currentUser._id ?? 'tmp_user') + "_"  + Date.now().toString(16) + "_" + Math.floor(Math.random() * 100000)
	}
	// 把 UTSAndroid.getDispatcher("io").async((_) => 封装成一个函数
	uniGetDispatcher(taskName: string, fn: () => void) {
		// #ifdef APP-ANDROID
		UTSAndroid.getDispatcher(taskName).async((_) => {
			fn()
		})
		// #endif
		// #ifndef APP-ANDROID
		fn()
		// #endif
	}
	addChat() {
		// 检查是否已经存在空会话，如果存在则直接选中，否则创建新会话
		const lastItem = this.chat.datas.length == 0 ? null : this.chat.datas[0] as ChatItem | null;
		if (lastItem?.msgList.length != 0) {
			const newChat: ChatItem = {
				id: this.getLocalMsgId(),
				title: "新对话",
				state: 'none',
				update_time: Date.now(),
				msgList: reactive<MsgItem[]>([]),
				inputContent: ''
			};
			this.chat.datas.unshift(newChat);
		}
		// 选中新创建的会话
		setTimeout(() => {
			this.chat.activeId = this.chat.datas[0].id
		}, 0)
	}
	get lastAiMsg(): MsgItem | null {
		// 获取Ai的最后一条消息(因为 msg 是倒叙的，所以取第一条)
		if (this.currentChat != null) {
			const length = this.currentChat!.msgList.length
			return length > 0 ? this.currentChat!.msgList[length - 1] : null;
		} else {
			return null;
		}
	}
	constructor() {
		// 从 storage 中获取数据
		uni.getStorage({
			key: 'uni-ai-chatList',
			success: (res) => {
				if (res.data != null){
					// #ifdef WEB
					res.data = res.data as ChatItem[]
					// #endif
					// #ifndef WEB
					const data = JSON.parse<ChatItem[]>(JSON.stringify(res.data)) as ChatItem[] | null
					res.data = data == null ? [] : data as ChatItem[]
					// #endif
				} else {
					this.addChat()
					res.data = [] as ChatItem[]
				}

				// console.error('res.data 获取成功', res.data)
				this.chat.datas.push(...(res.data as ChatItem[]))

				// console.error('uni-ai-chatList 获取成功', this.chat.datas)
				const chatList = this.chat.datas as ChatItem[]
				// 收 chat 的 state 设置为 none
				chatList.forEach((item) => {
					item.state = 'none'
				})
				// 默认选中第一个会话
				if (chatList.length == 0) {
					this.addChat()
				}
				this.chat.activeId = chatList[0].id
				// console.log('uni-ai-chatList 获取成功', this.chat.datas)
			},
			fail: (err: UniError) => {
				// console.error('uni-ai-chatList 获取失败', err.errMsg)
				this.addChat()
				// 默认选中第一个会话
				this.chat.activeId = this.chat.datas[0].id
			}
		})
		
		// 获取 setting
		uni.getStorage({
			key: 'uni-ai-setting',
			success: (res) => {
				if (res.data != null) {
					const setting = JSON.parse<Setting>(JSON.stringify(res.data)) as Setting
					this.setting = reactive<Setting>(setting)
				}
			},
			fail: (err) => {
				// console.error('uni-ai-setting 获取失败', err)
			}
		})

		// 在 IO 线程执行存储操作
		let saveStorageTimer: number | null = null
		watch((): ChatItem[] => this.chat.datas as ChatItem[], (newVal: ChatItem[] | null) => {
			if (newVal != null) {
				// console.error('chatList 发生变化', newVal)
				// 防止短时间内重复触发存储
				if (saveStorageTimer != null) {
					// console.error('防止短时间内重复触发存储')
					clearTimeout(saveStorageTimer as number)
				}
				saveStorageTimer = setTimeout(() => {
					// 存储到 storage 中
					uni.setStorage({
						key: 'uni-ai-chatList',
						data: newVal,
						success: () => {
							// console.log('uni-ai-chatList 存储成功', newVal)
						},
						fail: (err) => {
							console.error('uni-ai-chatList 存储失败', err)
						}
					})
				}, 1000)
			}
		}, { deep: true })

		watch((): Setting => this.setting, (newVal: Setting | null) => {
			if (newVal != null) {
				uni.setStorage({
					key: 'uni-ai-setting',
					data: newVal,
					success: () => {
						// console.log('uni-ai-setting 存储成功', newVal)
					},
					fail: (err) => {
						console.error('uni-ai-setting 存储失败', err)
					}
				})
			}
		}, { deep: true })
	}
	addMsg(msg: BaseMsgItem): MsgItem {
		// 添加一条消息
		const msgList = this.currentChat!.msgList
		const newMsg: MsgItem = {
			chat_id: this.currentChat!.id,
			_id: this.getLocalMsgId(),
			about_msg_id: msg.about_msg_id,
			body: msg.body,
			from_uid: msg.from_uid,
			create_time: Date.now(),
			state: 0,
			markdownElList: [] as markdownElItem[],
			rendered: false
		}
		msgList.push(newMsg)
		if (msg.from_uid != 'uni-ai') {
			// 把用户提的问题 内容的前 20 个字符作为标题，去掉换行符
			const title = msg.body.substring(0, 20).replace(/\n/g, '')
			this.currentChat!.title = title
		}
		// 更新会话的更新时间
		this.currentChat!.update_time = Date.now()
		// 返回响应式的 msg
		return msgList[msgList.length - 1]
	}
	deleteMsg(msgId: string) {
		// 查出消息索引
		const msgList = this.currentChat!.msgList
		const index = msgList.findIndex((item) => item._id == msgId)
		if (index != -1) {
			msgList.splice(index, 1)
		} else {
			console.error('需要删除的消息未找到', msgId, this.currentChat!.msgList)
			throw new Error('需要删除的消息未找到')
		}
	}
	abortRequest() {
		// 终止请求
		requestTask?.abort()
	}
	// 转换
	token2el(token: MarkdownToken): markdownElItem {
		return {
			uniqueId: token.uniqueId!,
			type: token.type!,
			datasList: treeToListSdk.markTreeToList(token)
		}
	}
	async sendMsg(inputContent: string = ''): Promise<void> {
		// 发送消息
		if (inputContent == '') {
			inputContent = this.currentChat!.inputContent
		}
		// 去除前后空格
		inputContent = inputContent.trim()
		if (inputContent.length == 0) {
			throw new Error('发给 AI 的消息不能为空');
		}
		console.log('send inputContent', inputContent);
		// 生成用户提问的消息
		let baseUserMsg: BaseMsgItem = {
			body: inputContent,
			from_uid: this.currentUser._id ?? 'tmp_user_'
		}
		const userMsg: MsgItem = this.addMsg(baseUserMsg)
		// console.log('before-send-msg', userMsg)

		// 生成一条空的 ai 回复的内容
		let baseAiMsgItem: BaseMsgItem = {
			body: '', // 初始是空的，后面慢慢追加
			from_uid: "uni-ai",
			about_msg_id: userMsg._id
		}
		const aiMsgItem: MsgItem = this.addMsg(baseAiMsgItem)
		return this.answerQuestion(aiMsgItem)
	}
	// 回答问题
	answerQuestion(aiMsgItem: MsgItem) {
		this.currentChat!.state = 'processing';
		let setRenderedTimer: number = 0;
		this.uniGetDispatcher("io", () => {
			const oldMarkdownTokenList: MarkdownToken[] = []
			checkThreadInMain('sendMsg')
			let delayTaskTimer: number = 0;
			let beforeUpdateMdElList: BeforeUpdateMdElList = (markdownTokenList: MarkdownToken[]) => {}
			let lockBeforeUpdateMdElList = false
			const setRendered = (rendered: boolean) => {
				this.uniGetDispatcher("main", () => {
					if (rendered == true){
						if (this.currentChat!.state != 'completed'){
							// console.log('setRendered 当前状态不是 completed', this.currentChat!.state)
							if (setRenderedTimer != 0) clearTimeout(setRenderedTimer)
							setRenderedTimer = setTimeout(() => {
								aiMsgItem.rendered = true
								setRenderedTimer = 0
							},
							// #ifdef APP-HARMONY
							1000
							// #endif
							// #ifndef APP-HARMONY
							 500
							// #endif
							)
						} else {
							aiMsgItem.rendered = true
						}
					} else {
						aiMsgItem.rendered = false
						setRenderedTimer = 0
					}
				})
			}
			beforeUpdateMdElList = (markdownTokenList: MarkdownToken[]) => {
				// 清除延迟任务
				if (delayTaskTimer != 0) {
					clearTimeout(delayTaskTimer)
				}
				if (!lockBeforeUpdateMdElList && this.canRender) {
					lockBeforeUpdateMdElList = true

					const newMarkdownTokenList = markdownTokenList.slice(0)
					const newLength = newMarkdownTokenList.length
					const oldLength = oldMarkdownTokenList.length
					

					// // 测试简化逻辑，直接全量更新
					// this.uniGetDispatcher("main", () => {
					// 	const newMarkdownElList = newMarkdownTokenList.map((item: MarkdownToken) => this.token2el(item))
					// 	// 直接赋值，避免频繁的数组操作
					// 	aiMsgItem.markdownElList = newMarkdownElList
					// })

					// 倒着检查，如果发现有不一样的，就更新。直到检查到有相同项为止
					let checkDiffCount: number = 0
					let checkDiff: CheckDiffFn = () => {}
					checkDiff = (index: number, checkDiffEndFn: CheckDiffEndFn)=>{
						if (index < 0 || index >= newLength) {
							checkDiffEndFn()
							return
						}
						if (oldMarkdownTokenList[index].uniqueId != newMarkdownTokenList[index].uniqueId) {
							checkDiffCount++
							// console.log('检查到不一样的', checkDiffCount)
							oldMarkdownTokenList[index] = newMarkdownTokenList[index]
							checkThreadInMain('checkDiff')
							const newMarkdownElListItem = this.token2el(newMarkdownTokenList[index])
							this.uniGetDispatcher("main", () => {
								aiMsgItem.markdownElList[index] = newMarkdownElListItem
								this.uniGetDispatcher("io", () => {
									checkDiff(index - 1, checkDiffEndFn)
								})
							})
						} else {
							checkDiffEndFn()
						}
					}
					

					const checkAndRemoveOldItems = (oldLength: number, newLength: number) => {
						// 如果旧的更长，则把多的部分删除
						if (oldLength > newLength) {
							oldMarkdownTokenList.splice(newLength)
							this.uniGetDispatcher("main", () => {
								// console.log('删除过期项', oldLength - newLength)
								aiMsgItem.markdownElList.splice(newLength, oldLength - newLength)
							})
						}
					}


					checkDiff(oldLength - 1, ()=>{
						// 如果新的更长，则把多的部分添加到 oldMarkdownTokenList 中
						if (newLength > oldLength) {
							const newItems = newMarkdownTokenList.slice(oldLength)
							oldMarkdownTokenList.push(...newItems)
							const newItemsElList = newItems.map((item: MarkdownToken) => this.token2el(item))
							this.uniGetDispatcher("main", () => {
								aiMsgItem.markdownElList.push(...newItemsElList)
								checkAndRemoveOldItems(oldLength, newLength)
								setRendered(true)
								this.uniGetDispatcher("io", () => {
									lockBeforeUpdateMdElList = false
								})
							})
						} else {
							checkAndRemoveOldItems(oldLength, newLength)
							setRendered(true)
							lockBeforeUpdateMdElList = false
						}
					})
				} else {
					setRendered(false)
					// 创建延迟任务
					delayTaskTimer = setTimeout(()=>{
						beforeUpdateMdElList(markdownTokenList)
					}, 500)
				}
			}
			const parseMarkdown = new ParseMarkdown(beforeUpdateMdElList)
			const isDemo = false;
			if (isDemo == false) { // 1个字为一批往 this.msg.body 上追加
				checkThreadInMain('before requestAi')
				const messages = this.getMsgToAi(this.currentChat!)
				this.requestAi(messages,(chunkObj: Chunk) => {
					checkThreadInMain('requestAi onChunk')
					// console.log('chunkObj', chunkObj)
					const content = chunkObj.choices?.[0]?.delta?.content
					const reasoningContent = chunkObj.choices?.[0]?.delta?.reasoning_content
					this.uniGetDispatcher("main", () => {
						if (this.currentChat!.state == 'stop') {
							console.warn('请求已被终止')
							return
						}
						if (content != null) {
							aiMsgItem.body += content
						} else if (reasoningContent != null) {
							aiMsgItem.thinkContent = (aiMsgItem.thinkContent ?? '') + reasoningContent
						} else {
							console.error('content == null')
						}

						if (content != null || reasoningContent != null){
							// 在主线程中获取 body 的副本，避免在 IO 线程中访问响应式对象
							const msgBody = aiMsgItem.body
							this.uniGetDispatcher("io", () => {
								parseMarkdown.runTask(msgBody)
							})
						}
					})
				}).then((res) => {
					// console.log('requestAi then', res)
					this.uniGetDispatcher("main", () => {
						console.log('流式数据结束')
						this.currentChat!.state = 'completed';
						// 多加个换行结尾方便解析，防止解析到最后一行时，没有换行符，导致解析失败
						if (!aiMsgItem.body.endsWith('\n')) {
							aiMsgItem.body += "\n"
							const aiMsgItemBody = aiMsgItem.body
							this.uniGetDispatcher("io", () => {
								// console.log('加个换行继续解析', aiMsgItemBody, aiMsgItemBody.length)
								parseMarkdown.runTask(aiMsgItemBody)
							})
						}
					})
					// 让阿里百联总结更新
					this.updateChatTitle(this.currentChat!, messages)
				}).catch((errRes) => {
					errRes = errRes as UTSJSONObject
					// console.error('requestAi catch', errRes)
					// 回到主线程更新状态
					this.uniGetDispatcher("main", () => {
						// 状态为 stop 为用户手动执行了 停止 不需要再次提示用户
						if (this.currentChat!.state != 'stop'){
							this.currentChat!.state = 'stop';
							const errCode = errRes.getString('errCode', '')
							let errMsg = errRes.getString('errMsg', '未知错误')
							console.log('errCode', errCode)
							console.log('errMsg', errMsg)
							if (errCode == 'data_inspection_failed') {
								errMsg = '数据检查失败，疑似包含敏感信息'
							}
							aiMsgItem.error_msg = errMsg
						}
					})
				})
			} else {
				this.uniGetDispatcher("main", () => {
					this.emitBeforeRequestAi()
				})
				let i = 0
				let timer: number = 0
				timer = setInterval(() => {
					if (i >= testMarkdownText.length) {
						clearInterval(timer)
						this.uniGetDispatcher("main", () => {
							this.currentChat!.state = 'completed'
						})
					} else {
						const batchSize = 3
						const endIndex = Math.min(i + batchSize, testMarkdownText.length)
						this.uniGetDispatcher("main", () => {
							const newText = testMarkdownText.slice(i, endIndex)
							// console.log('aiMsgItem.body', aiMsgItem.body, newText)
							aiMsgItem.body += newText
							// console.log('aiMsgItem.body', aiMsgItem.body)
							i = endIndex
							// 在主线程中获取 body 的副本，避免在 IO 线程中访问响应式对象
							const msgBody = aiMsgItem.body
							this.uniGetDispatcher("io", () => {
								parseMarkdown.runTask(msgBody)
							})
						})
					}
				}, 100)
			}
		})
	}
	// 拿到消息列表，用于发给 AI 
	getMsgToAi(chatItem: ChatItem): RequestAiCoMessage[] {
		const messages: RequestAiCoMessage[] = [];
		chatItem.msgList.forEach((item) => {
			messages.push({
				role: item.from_uid == 'uni-ai' ? 'assistant' : 'user',
				content: item.body as string
			})
		})
		return messages
	}
	beforeRequestAiFns: BeforeRequestAiFn[] = []
	onBeforeRequestAi(fn: BeforeRequestAiFn) {
		this.beforeRequestAiFns.push(fn)
	}
	emitBeforeRequestAi() {
		this.beforeRequestAiFns.forEach((fn) => {
			fn()
		})
	}
	// 子线程请求AI
	requestAi(messages: RequestAiCoMessage[],onChunkFn: OnChunkFn): Promise<UTSJSONObject> {
		return new Promise<UTSJSONObject>((resolve, reject) => {
			this.uniGetDispatcher("main", () => {
				this.emitBeforeRequestAi()
				this.currentChat!.state = 'processing'
			})
			if (this.llm.provider == 'bailian') {
				this.requestBailian({
					messages,
					stream: true,
					onChunk: onChunkFn,
					onError: reject,
					onDone: resolve
				})
			} else {
				reject({
					errCode: -100,
					errMsg: '不支持的模型: ' + this.llm.model
				} as UTSJSONObject)
			}
		})
	}
	// 让阿里百联总结更新
	async updateChatTitle(currentChat: ChatItem, messages: RequestAiCoMessage[]): Promise<void> {
		messages.push({
			role: 'user',
			content: '请总结一下这段对话的内容，不包含本对话，用于更新会话的标题。注意：可以直接使用的不要有多余的文字，只保留总结的内容。字数控制在 10 个字以内。'
		})
		await this.requestBailian({
			messages,
			stream: false,
			onError: (err: UTSJSONObject) => {
				console.error('updateChatTitle error', err)
			},
			onSuccess: (chunkObj: Chunk) => {
				// console.log('updateChatTitle success', chunkObj, typeof chunkObj)
				const newTitle = chunkObj.choices?.[0]?.message?.content
				this.uniGetDispatcher("main", () => {
					currentChat.title = newTitle ?? '更新失败'
					// console.log('updateChatTitle success', 'newTitle', newTitle, chunkObj)
				})
			}
		})
	}
	async requestBailian(options : BailianOptions) : Promise<UTSJSONObject> {
		let resolveFn = (_ : UTSJSONObject) : void => { }, rejectFn = resolveFn;
		const config : Provider = llmModelMap.get(this.llm.provider)!
		// 请求的token
		let tmpToken : string;
		try {
			tmpToken = await config.getToken?.()!
		} catch (e) {
			options.onError?.({
				errCode: -100,
				errMsg: '获取临时token失败'
			} as UTSJSONObject)
			return new Promise<UTSJSONObject>((resolve, reject) => {
				reject({
					errCode: -100,
					errMsg: '获取临时token失败'
				} as UTSJSONObject)
			})
		}
		checkThreadInMain('getToken')
		this.uniGetDispatcher("io", () => {
			checkThreadInMain('requestBailian')
			requestTask = uni.request({
				url: config.baseURL!,
				method: 'POST',
				dataType: 'text',
				data: {
					messages: options.messages,
					stream: options.stream ?? true,
					model: this.llm.model
				},
				enableChunked: options.stream ?? true,
				header: {
					'Authorization': `Bearer ${tmpToken}`,
					'Content-Type': 'application/json'
				},
				success: (res : RequestSuccess<any>) => {
					if (options.stream == false) {
						// console.error('非流式数据----',res.data,typeof res.data)
						const strData = typeof res.data == 'string' ? res.data : JSON.stringify(res.data)
						const chunkObj : Chunk = (JSON.parse<Chunk>(strData) ?? {}) as Chunk
						options.onSuccess?.(chunkObj)
					} else {
						if (res.data instanceof UTSJSONObject) {
							// 部分情况下（内容包含违禁词时），流式响应未返回数据，就立即结束请求。此时错误信息会放在 data 中
							const error = res.data.getJSON('error')
							if (error != null) {
								// console.log('error', error)
								options.onError?.({
									errCode: error.getString('code', 'unknown'),
									errMsg: error.getString('message', '未知错误')
								} as UTSJSONObject)
								return
							}
						}
						resolveFn({} as UTSJSONObject)
					}
				},
				fail: (err : RequestFail) => {
					console.error('request fail', err)
					rejectFn({
						errCode: err.errCode,
						errMsg: err.errMsg
					} as UTSJSONObject)
				},
				complete: () => {
					requestTask = null
				}
			})
			if (options.stream == true) {
				requestTask?.onChunkReceived((chunk : RequestTaskOnChunkReceivedListenerResult) => {
					checkThreadInMain('requestBailian onChunkReceived')
					// console.log('onChunkReceived-----------------------------------', chunk)
					parseChunkData(chunk.data as ArrayBuffer, (chunkObj : Chunk) => {
						options.onChunk?.(chunkObj)
					},
					(err : UTSJSONObject) => {
						err.errCode = err.code ?? ''
						err.errMsg = err.message ?? '未知错误'
						// console.error('parseChunkData error', err)
						options.onError?.(err)
						rejectFn(err)
					},
					() => {
						console.log('流式数据结束')
						options.onDone?.({} as UTSJSONObject)
					})
				})
			}
		})
		return new Promise<UTSJSONObject>((resolve, reject) => {
			resolveFn = (data : UTSJSONObject) => { resolve(data as UTSJSONObject) }
			rejectFn = (data : UTSJSONObject) => { reject(data as UTSJSONObject) }
		})
	}
}

const uniAi = new UniAi()
export { uniAi }
export default uniAi

// #ifdef WEB
// 方便在控制台观察
window.uniAi = uniAi
// #endif

// 解析流式数据
function parseChunkData(chunkData: ArrayBuffer, callback: (chunkObj: Chunk) => void, errorCallback: (err: UTSJSONObject) => void, doneCallback: () => void) {
	checkThreadInMain('parseChunkData')
	const chunkText: string = new TextDecoder().decode(chunkData)
	// console.error('chunkText======', chunkText)
	const lines: string[] = chunkText.trim().split('\n\n')
	// console.error('lines======', lines, lines.length)
	lines.forEach((line: string) => {
		line.split('\n').forEach((lineItem: string) => {
			const keyValue: string[] = lineItem.split(':')
			const key: string = keyValue[0]
			const value: string = keyValue.slice(1).join(':')
			if (key == 'data') {
				if (value == " [DONE]") {
					doneCallback()
					return
				}
				let chunk: Chunk | null = null
				try {
					chunk = JSON.parse<Chunk>(value) as Chunk
				} catch (e) {
					console.error('JSON.parse error', e, 'value:', value)
				}
				// console.log('chunk',chunk)
				callback(chunk ?? {} as Chunk);
			} else if (key == '{"error"') {
				// console.error('parseChunkData error', {key,value})
				let info: UTSJSONObject = {}
				try {
					info = JSON.parse<UTSJSONObject>('{"error":' + value) as UTSJSONObject
				} catch (e) {
					console.error('JSON.parse error', e, 'value:', value)
				}
				errorCallback(info.error! as UTSJSONObject)
				doneCallback()
			} else {
				callback({} as Chunk);
			}
		})
	})
}